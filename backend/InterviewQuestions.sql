INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (1, 'Виды чтения в транзакциях', '1. Read Uncommited - чтение незафиксированных изменений.

2. Read Commited - чтение зафиксированных данных

3. Reapetable read - чтение изменений только своей транзакций

4. Serializable - изоляция транзакции внутри отдельно от других', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (2, 'Разница между .Result от Await', '1. Отдаёт в случае исключения AggregateException 

2. Блокирует поток 

3. Теряется callstask и происходит это всё без синхронизации контекста, т.к. всё в одном потоке.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (3, 'Из чего состоит pipeline ASP NET?', 'Pipeline состоит из ПО промежуточного слоя (middleware) 

https://docs.microsoft.com/ru-ru/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (4, 'Принципы ACID (транзакций)', 'A - атомарность. То есть операции применятся полностью и выполнятся как единое целое.

C - согласованность. Изменения будут включать только допустимые значения.

I - изолированность. Выполнится без влияния на другие транзакции

D - долговечность. Изменения должны оставаться вне зависимости от сбоев', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (5, 'Сложности структур (алгоритмов)', 'Полезные ссылки:

https://miro.medium.com/max/10000/1*wv3W3jYq7EHCDiwYVaCXrA.png

https://habr.com/ru/post/188010/', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (6, 'Что такое интерфейс?', 'Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации. Что может определять интерфейс? В целом интерфейсы могут определять следующие сущности: Методы, Свойства, Индексаторы, События, Статические поля и константы (начиная с версии C# 8.0)', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (7, 'Redis - что это и для чего?', 'Redis - это высокоскоростное key-value хранилище в быстрой памяти.
Может служить как кэш и как "глупый" брокер сообщений.

+ Скорость за счет нахождения в быстрой памяти
+ удобные запросы не требующие "подготовки" 
+ возможность организовывать поиск по geo, статистическим алгоритмам (Hyperloglog ), hash – если коротко, то хэш в Redis делают между строковыми полями и их значениями.

Если данные нуждаются в усиленной защите, Редис подойдет в меньшей степени, лучше посмотрите в сторону MongoDB или Elasticsearch

https://wiki.merionet.ru/servernye-resheniya/21/redis-chto-eto-i-dlya-chego/', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (8, 'Action Filters', 'https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters/_static/filter-pipeline-1.png?view=aspnetcore-5.0

https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters/_static/filter-pipeline-2.png?view=aspnetcore-5.0


https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-5.0', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (9, 'Полный путь запроса в браузере?', 'Если кратко, то вот.

1. Проверка списка HSTS (HTTP Strict transport security), то есть проверяется можно ли отправить через HTTPS, если нет, то отправляется через HTTP

2. Запрос в DNS и в HOSTS, с начала проверяется есть ли домен и его  айпишник в HOSTS ОС, если нет, то делается запрос в DNS (получение IP вместе с портом)

3. TLS Handshake
С начала отправляется сообщение на сервер "Client hello", где указывается TLS версия, список алг. шифрования и доступные методы. 
Сервер далее отвечает "server hello" и отдаёт доступный публичный сертификат.(серт. состоит из публичного ключа)
Клиент проверяет через С Auth, если ОК, то создаётся в итоге симметричный ключ. 
Устанавливается TLS сессия.

4. Браузер отправляет HTTP запрос чтоб получить контент 

5. Сервер обрабатывает запрос и отдаёт результат

6. Браузер получает данные в виде HTML, CSS, Js файлов. Парсит и строит DOM дерево', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (10, 'Виды индексов в Postgres', 'Hash - более слабая "версия" BTree. Не может участвовать в репликации и уступает по универсальности.

BTree (b - balanced) - для данных которые  можно сортировать (>,<, =).
Делит данные на страницы, где страницы одного уровня связаны двухсвязным списком


Gist -  сбалансированное по высоте дерево поиска, состоящие из узлов(страниц) . Преследует принцип распределения данных произвольного типа по BTree

SP-Gist - подходит для структур, в которых пространство рекурсивно разбивается на непересекающиеся области
идея индексного метода SP-GiST состоит в разбиении области значений на неперекрывающиеся подобласти, каждая из которых, в свою очередь, также может быть разбита. Такое разбиение порождает несбалансированные деревья (в отличие от B-деревьев и обычного GiST).

GIN - Generailzer inverted index (обратный индекс) - для типов данных, которые состоят из элементов (массив, json, полнотекстовый поиск)

Brin - неточный индекс. Для пропуска заведомо не нужных данных, за счёт разбиения на зоны (range).

Rum - для более развитого и производительного полнотекстового поиска

https://habr.com/ru/company/postgrespro/blog/346460/', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (11, 'Volatile & Interlocked', 'Ключевое слово volatile означает, что поле может изменять несколько потов одновременно, при этом избегая Race Condition. Для достижения данной возможности не применяются оптимизации к этому полю при компиляции.

Класс Interlocked позволяет создавать простые операторы для атомарных операций с переменными. Например, операция i++ не является безопасной в отношении потоков. ', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (12, 'Принципы SOLID?', 'S (The Single Responsibility Principle) - принцип единой ответственности (SRP). 
Один класс отвечает за одну предметную область.

O (The Open Closed Principle) - обозначает принцип открытости/закрытости (OCP).
Класс должен быть закрыт для модификаций, но открыт для расширения.

L (The Liskov Substitution Principle) – принцип подстановки Лисков, описывающий возможности заменяемости экземпляров объектов (LSP).
Возможность классов подставлять любой более базовый или производный класс

I (The Interface Segregation Principle) - принцип разделения интерйесов (ISP).
Разделение интерфейсов на более мелкие, для повторного использования и удобной кастомизации.

D (The Dependency Inversion Principle) - принцип инверсии зависимостей (DIP).
Классы высшего уровня не зависят от более низкоуровневых.
При этом лишь зависят от абстракции, а не от конкретной реализации.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (13, 'Akka.NET и модель Actor', 'Actor - математическая модель параллельных вычислений. Состоящая из Actor''ов, включающих в себя Mailbox и State. Actor''ы общаются между собой асинхронными сообщениями, что позволяет создать высоконагруженные распределенные облачные системы, а состояния могут хранить определённые данные для быстрого доступа.

* Actor дают высокий уровень абстракции для параллелизма, асинхронно не блокирующую event-модель и лёгкие событийные процессы.

* Позволяет реализовать отказоустойчивую систему

* Даёт возможность горизонтально и вертикально масштабироваться.

https://habr.com/ru/company/pixonic/blog/426115/

https://habr.com/ru/post/320396/', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (14, 'Что такое оптимистичная и пессимистичная блокировка?', 'Оптимистичная блокировка не блокирует строки, а лишь сравнивает VERSION, пессимистичная блокирует задействуемые строки.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (15, 'В какую конструкцию разворачивается lock?', 'System.Threading.Monitor.Enter(obj);
try
{
    //action
}
finally
{
    System.Threading.Monitor.Exit(obj);
}', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (16, 'Что знаете о CORS?', 'Технология, позволяющая получить доступ клиенту к  нескольким защищённым источникам данных. 

(Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.)', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (17, 'Что такое абстрактный класс?', 'Абстрактный класс - это класс, экземпляр которого невозможно создать, при этом в нём один или несколько методов может быть не реализовано. Основная его концепция заключается в том, чтобы избежать копипасты кода, выделив для схожих по сути сущностей общие элементы.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (18, 'Dependecy Injection', 'Transient: при каждом обращении к сервису создается новый объект сервиса.

Scoped: для каждого запроса создается свой объект сервиса.

Singleton: объект сервиса создается при первом обращении к нему, все последующие запросы используют один и тот же ранее созданный объект сервиса

Captive Dependecy - "ошибка", когда долгоживущая зависимость захватывает менее долгоживущую зависимость (синглтон захватил transient) ', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (19, 'Разница IEnumerable<T> и IQueryable<T> при работе с удаленной БД?', 'Разница между <b>IQueryable</b> и <b>IEnumerable</b> заключается в том, где выполняется логика фильтра. Один выполняется на стороне клиента, а другой-на базе данных.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (20, 'В чем основные отличия класса от структуры(struct) в языке C#?', 'Многие ошибочно говорят, что структура хранится в стеке, а класс в куче, но это справедливо в очень простых случаях(ибо в сложных они все равно могут скинуться в кучу), главное отличие структур и классов: структуры, указываемые в списке параметров метода, передаются по значению (то есть копируются), объекты классов — по ссылке. Именно это является главным различием в их поведении, а не то, где они хранятся.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (21, 'Возможно ли поместить два файла с одинаковым именем в Global Assembly Cache?', 'Да, возможно, поскольку GAC не является обычной директорией, в которую невозможно поместить два файла с одинаковыми именами. Файлы дифференцируются также по версии, поэтому в GAC вполне могут сосуществовать к примеру два файла somelib.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (22, 'Описания кластеризованных и некластеризованных индексов', '<li> Кластеризованный </li>
<ul> Кластеризованные индексы сортируют и хранят строки данных в таблицах или представлениях на основе их ключевых значений. Этими значениями являются столбцы, включенные в определение индекса. Существует только один кластеризованный индекс для каждой таблицы, так как строки данных могут храниться в единственном порядке. </ul>
<ul> Строки данных в таблице хранятся в порядке сортировки только в том случае, если таблица содержит кластеризованный индекс. Если у таблицы есть кластеризованный индекс, то таблица называется кластеризованной. Если у таблицы нет кластеризованного индекса, то строки данных хранятся в неупорядоченной структуре, которая называется кучей. </ul>
<li> Некластеризованный </li>
<ul> Некластеризованные индексы имеют структуру, отдельную от строк данных. В некластеризованном индексе содержатся значения ключа некластеризованного индекса, и каждая запись значения ключа содержит указатель на строку данных, содержащую значение ключа. </ul>
<ul> Указатель из строки индекса в некластеризованном индексе, который указывает на строку данных, называется указателем строки. Структура указателя строки зависит от того, хранятся ли страницы данных в куче или в кластеризованной таблице. Для кучи указатель строки является указателем на строку. Для кластеризованной таблицы указатель строки данных является ключом кластеризованного индекса. </ul>', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (23, 'Stack и Heap', '<b>Стек</b>
<br/>
<br/>
Стек — это область оперативной памяти, которая создаётся для каждого потока. Он работает в порядке LIFO (Last In, First Out),  то есть последний добавленный в стек кусок памяти будет первым в очереди на вывод из стека. Каждый раз, когда функция объявляет новую переменную, она добавляется в стек, а когда эта переменная пропадает из области видимости (например, когда функция заканчивается), она автоматически удаляется из стека. Когда стековая переменная освобождается, эта область памяти становится доступной для других стековых переменных.

Из-за такой природы стека управление памятью оказывается весьма логичным и простым для выполнения на ЦП; это приводит к высокой скорости, в особенности потому, что время цикла обновления байта стека очень мало, т.е. этот байт скорее всего привязан к кэшу процессора. Тем не менее, у такой строгой формы управления есть и недостатки. Размер стека — это фиксированная величина, и превышение лимита выделенной на стеке памяти приведёт к переполнению стека. Размер задаётся при создании потока, и у каждой переменной есть максимальный размер, зависящий от типа данных. Это позволяет ограничивать размер некоторых переменных (например, целочисленных), и вынуждает заранее объявлять размер более сложных типов данных (например, массивов), поскольку стек не позволит им изменить его. Кроме того, переменные, расположенные на стеке, всегда являются локальными.

В итоге стек позволяет управлять памятью наиболее эффективным образом — но если вам нужно использовать динамические структуры данных или глобальные переменные, то стоит обратить внимание на кучу.
<br/>
<br/>
<b>Куча</b>
<br/>
Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти и не работает по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. Именно так определяются глобальные переменные. По завершении приложения все выделенные участки памяти освобождаются. Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь физически, и это позволяет создавать динамические переменные.

Вы взаимодействуете с кучей посредством ссылок, обычно называемых указателями — это переменные, чьи значения являются адресами других переменных. Создавая указатель, вы указываете на местоположение памяти в куче, что задаёт начальное значение переменной и говорит программе, где получить доступ к этому значению. Из-за динамической природы кучи ЦП не принимает участия в контроле над ней; в языках без сборщика мусора (C, C++) разработчику нужно вручную освобождать участки памяти, которые больше не нужны. Если этого не делать, могут возникнуть утечки и фрагментация памяти, что существенно замедлит работу кучи.

В сравнении со стеком, куча работает медленнее, поскольку переменные разбросаны по памяти, а не сидят на верхушке стека. Некорректное управление памятью в куче приводит к замедлению её работы; тем не менее, это не уменьшает её важности — если вам нужно работать с динамическими или глобальными переменными, пользуйтесь кучей.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (24, 'REST API', 'REST API - архитектурный стиль взаимодействия распределённого приложения в сети.
<br/>
Предполагает в себе ресурсы:
<br>
<ul>корневые (независимые): то есть основная выделенная сущность (api/stations/123 - получить информацию по вокзалу с ID = 123)</ul>
<ul>зависимые (от корневой): то есть зависимая от корневой сущность (api/stations/123/departures -  поезда, уходящие с вокзала 555) </ul>
<br/>
Основные методы
<br>
GET - получить список записей ресурса
<br>
GET:id - получить ресурс по ID
<br>
POST - создание ресурса
<br>
PUT - создание/обновление ресурса
<br>
PATCH - частичное обновление ресурса', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (25, 'Mutex, Semaphore, EventWaitHandle - синхронизация потоков', 'Класс Mutex - позволяет обеспечить синхронизацию среди множества процессов. Он очень похож на класс Monitor(lock) тем, что тоже допускает наличие только одного владельца. Только один поток может получить блокировку и иметь доступ к защищаемым мьютексом синхронизированным областям кода. Т.е. предоставляет потоку монопольный доступ к ресурсу. С помощью Mutex вы можете контролировать количество запущенных инстансов приложения

Semaphore - Семафор подобен мьютексу, за исключением того, что он предоставляет одновременный доступ к общему ресурсу не одному, а нескольким потокам. Поэтому семафор пригоден для синхронизации целого ряда ресурсов. Семафор управляет доступом к общему ресурсу, используя для этой цели счетчик. Если значение счетчика больше нуля, то доступ к ресурсу разрешен. А если это значение равно нулю, то доступ к ресурсу запрещен. С помощью счетчика ведется подсчет количества разрешений. Следовательно, для доступа к ресурсу поток должен получить разрешение от семафора.

EventWaitHandle - Класс EventWaitHandle позволяет потокам взаимодействовать друг с другом, передавая и ожидая передачи сигналов. (вот один из примеров, самый простой. Тут мы производим к-либо работу в одном потоке, а второй ждет ее завершения. Когда работа завершилась - сигналим из дополнительного потока основному, что можно продолжать.)', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (26, 'Разница между Делегатом и событием (event)', 'Ключевое слово event ни что иное, как синтаксический сахар, позволяющий добавить дополнительное поведение свойству типа делегата. Проблема, которую синтаксически решают события — это сделать так, чтобы мы не могли случайно переопределить всю цепочку вызовов методов, добавленных к переменной типа делегата. Вы можете использовать псевдо методы (почти аналог геттера и сеттера) add & remove, за исключением что event будет оберткой вокруг переменной типа делегата. Также, если нам не нужны псевдо-методы add & remove ключевое слово event не позволяет сделать присвоение делегата извне класса, тем самым переписав всю цепочку вызовов.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (27, 'Разница между локальными функциями и делегатами', 'Локальную функцию можно определить в конце метода, переменную делегата только перед использованием. Главное, что нужно понимать, локальная функция не является делегатом и не преобразуется в делегат во время использования, следовательно, не будет потреблять ресурсы в управляемой куче. В целом, локальные функции и делегаты имеют разные сферы применения. Локальные функции более уместны для выделения заново используемого куска кода внутри конкретного метода.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (28, 'Зачем нужны Properties & Fields', 'Property (свойство) — используется как внешний контракт класса Field (поле) — как приватный член класса. Интерфейсы синтаксически позволяют работать только со свойствами, так же объявляя для них псевдо методы get & set. Свойства могут быть virtual & override, но вот управлять приватностью псевдо методов в переопределенном свойстве в наследнике не выйдет.

', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (29, 'Разница Readonly и const модификаторов', 'Const — на этапе компиляции производит inline подстановку значения. Readonly же защищает поле от изменения после выполнения конструктора. Следовательно, для того, чтобы значение из const подставилось в другие сборки — необходима их перекомпиляция.<br>
Т.е. Const инициализируется при запуске приложения и нельзя изменить. Readonly можно проинициализовать в конструкторе, но изменить нельзя, так же можно изменить через рефлексию.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (30, 'Ко и Контр — вариантность в C#', 'Ко и контр вариантность — это возможность производить неявное преобразование обобщенных параметров, в обобщенных делегатах и интерфейсах. Т.к. Ключевое слово out указывает, что на месте параметра T может быть сам класс так и его родительские классы, как в сигнатуре интерфейса IEnumerable. Для ключевого слова in — наоборот, сам класс и его производные.', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (31, 'Что будет если вызвать метод без await?', 'Метод запустится параллельно и мы не узнаем о его результате, пока не вызовем await', 1305906373587443712);
INSERT INTO InterviewQuestions (Id, Question, Answer, DateCreation) VALUES (32, 'Как работают Thread и Task, async-await', 'Класс Task представляют собой асинхронную операцию, а в классе Thread инкапсулируется поток исполнения.<br/>
По факту Task выполняется в Thread.<br/>
И Thread выделен квант времени, после завершения которого переходит на другой по приоритету поток. Значения текущего потока сохраняются в регстре процессора. Например в windows это было 30мс на поток.<br/>
Что позволяет реализовывать систему с быстрым откликом и не зацикливаться на исполнении только активных в данный момент потокам.<br/>
<br/>
Thread создаётся из текущего ThreadPool, т.к. уничтожать и создавать новые потоки медленно и затратно. Дешевле "заготовить"  их при старте приложения
<br/>
Так же чем больше поддерживаемых потоков в ядрах процессорах, тем больше потоков могут выполняться одновременно.
<br/>
async - означает, что метод МОЖЕТ! выполняться асинхронно не блокируя поток.
<br/> 
так же когда вызывается await, то означает ожидание выполнения без блокировки текущего потока в отличии от синхронных методов или вызова .Result
', 1305906373587443712);